#include "model-owner.hpp"
#include <iostream>

#ifdef PTXT_MODEL
#define get_vector encode_vector
#define get_matrix encode_matrix
#else
#define get_vector encrypt_vector
#define get_matrix encrypt_matrix
#endif

// encrypt the plaintext representation of the model
CtxtModelDescription *ModelOwner::encrypt(PtxtModelDescription ptxt)
{

    helib::PubKey &pk = *info.sk;
    auto *ctxt = new CtxtModelDescription();

    ctxt->k = ptxt.k;
    ctxt->name = ptxt.name;
    ctxt->bits = ptxt.bits;

    ctxt->depth = ptxt.level_mask.size();
    ctxt->width = ptxt.d2b.size();
    ctxt->quantized = ctxt->width == 0 ? 0 : ptxt.d2b[0].size();
    ctxt->slots = ptxt.level_b2s[0].size();

    auto bitvecs = decompose_bits(ptxt.thresholds, ptxt.bits);
    for (int i = 0; i < ptxt.bits; i++)
        ctxt->thresholds.push_back(get_vector(info, bitvecs[i]));

    ctxt->d2b = ctxt->width == 0 ? std::vector<model_vec>{} : get_matrix(info, ptxt.d2b);
    ctxt->level_b2s.reserve(ptxt.level_b2s.size());
    ctxt->level_mask.reserve(ptxt.level_mask.size());

    for (auto bts : ptxt.level_b2s)
        ctxt->level_b2s.push_back(get_matrix(info, bts));

    for (auto mask : ptxt.level_mask)
        ctxt->level_mask.push_back(get_vector(info, mask));

    return ctxt;
}

// creates the plaintext model (generated by Haskell code) and encrypts it
CtxtModelDescription *ModelOwner::GenerateModel()
{
    return encrypt(plaintext_model());
}